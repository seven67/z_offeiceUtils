package person.seven.nio;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;/** * @description: * @author: liuqi create on 2018/5/4 **/public class Servers implements Runnable {    private Selector selector;    private ByteBuffer readBuffer = ByteBuffer.allocate(1024);    public Servers(int port) {        try {            this.selector = Selector.open();            ServerSocketChannel ssc = ServerSocketChannel.open();            ssc.configureBlocking(false);            ssc.bind(new InetSocketAddress(port));            ssc.register(this.selector, SelectionKey.OP_ACCEPT);            System.out.println("服务器启动  ： 端口 "+port);        } catch (IOException e) {            e.printStackTrace();        }    }    @Override    public void run() {        while (true){            try {                this.selector.select();                Iterator<SelectionKey> keys = this.selector.selectedKeys().iterator();                while (keys.hasNext()){                    SelectionKey key = keys.next();                    keys.remove();                    if(key.isValid()){                        if(key.isAcceptable()){                            this.open(key);                        }                        if(key.isReadable()){                            this.read(key);                        }                    }                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    private void read(SelectionKey key) {        try {            this.readBuffer.clear();            SocketChannel sc = (SocketChannel) key.channel();            int count = sc.read(this.readBuffer);            if(count == -1){                key.channel().close();                key.cancel();                return;            }            this.readBuffer.flip();            byte[] bytes = new byte[this.readBuffer.remaining()];            this.readBuffer.get(bytes);            System.out.println("服务端收到数据："+ new String(bytes).trim());        } catch (IOException e) {            e.printStackTrace();        }    }    private void open(SelectionKey key) {        try {            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();            SocketChannel sc = ssc.accept();            sc.configureBlocking(false);            ssc.register(this.selector,SelectionKey.OP_READ);        } catch (IOException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        Executors.newSingleThreadExecutor().submit(new Servers(1024));    }}