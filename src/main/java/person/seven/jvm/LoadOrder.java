package person.seven.jvm;/** * @description: * @author: liuqi create on 2019/1/11 **/public class LoadOrder {    static {        System.out.println("静态初始化Demo01");    }    public static void main(String[] args) throws Exception {        System.out.println("Demo01的main方法！");        System.out.println(System.getProperty("java.class.path"));        /** 类的主动引用（一定会发生类的初始化）         new一个类的对象         调用类的静态成员（除了final常量）和静态方法         使用java.lang.reflect包的方法对类进行反射调用         当虚拟机启动，java Demo01,则一定会初始化Demo01类，说白了就是先启动main方法所在的类         当初始化一个类，如果其父类没有被初始化，则先初始化它父类         *///        new A();//        System.out.println(A.width);//        Class.forName("com.sinosoft.test.A");        /** 类的被动引用（不会发生类的初始化）         当访问一个静态域时，只有真正声名这个域的类才会被初始化         通过子类引用父类的静态变量，不会导致子类初始化         通过数组定义类的引用，不会触发此类初始化         引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）         */        System.out.println(A.MAX);        A[] as = new A[10];        System.out.println(B.width);//B类不会被加载    }}class B extends A {    static {        System.out.println("静态初始化B");    }}class A extends A_Father {    public static int width = 100;   //静态变量，静态域    field    public static final int MAX = 100;    static {        System.out.println("静态初始化类A");        width = 300;    }    public A() {        System.out.println("创建A类的对象");    }}class A_Father extends Object {    static {        System.out.println("静态初始化A_Father");    }}