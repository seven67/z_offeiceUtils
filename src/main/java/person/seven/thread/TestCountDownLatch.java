package person.seven.thread;import com.google.common.collect.Lists;import java.util.List;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.stream.Collectors;/** * @description: 多线程并发 * @author: liuqi create on 2018/4/8 **/public class TestCountDownLatch {    private static final int RUNNER_NUMBER = 5; // 运动员个数    private static final int READY_TIME = 500; // 允许预备时间    private static final Random RANDOM = new Random();    public static void main(String[] args) {        CountDownLatch runnerReadyLatch = new CountDownLatch(RUNNER_NUMBER);        CountDownLatch startMessageLatch = new CountDownLatch(1);//        Executors.newFixedThreadPool(RUNNER_NUMBER);        List<Runner> threadList = Lists.newArrayList();        for (int i = 0; i < RUNNER_NUMBER ; i++) {            threadList.add(new Runner(i+1+"号运动员",runnerReadyLatch,startMessageLatch));        }        threadList.stream().forEach(thread -> thread.start());        boolean readyAll = true;        try {            readyAll = runnerReadyLatch.await(READY_TIME, TimeUnit.MILLISECONDS);//            runnerReadyLatch.await();        } catch (InterruptedException e) {            System.out.println("预备时间");        }        if(readyAll){            startMessageLatch.countDown();            System.out.println("所有运动员准备就绪！裁判员宣布，开跑！");        }else{            threadList.stream().forEach(thread -> { if(thread.getReadyTime() > READY_TIME){ thread.setReady(false); }});            System.out.println("部分运动员为准备就绪！裁判员宣布，开跑！");            startMessageLatch.countDown();        }    }    static class Runner extends Thread {        private String name;        private CountDownLatch runnerReadyLatch;        private CountDownLatch startMessageLatch;        private Integer readyTime ;        private volatile boolean ready = true ;        public Runner(String name, CountDownLatch runnerReadyLatch, CountDownLatch startMessageLatch) {            this.name = name;            this.runnerReadyLatch = runnerReadyLatch;            this.startMessageLatch = startMessageLatch;        }        public boolean isReady() {            return ready;        }        public void setReady(boolean ready) {            this.ready = ready;        }        public Integer getReadyTime() {            return readyTime;        }        public void setReadyTime(Integer readyTime) {            this.readyTime = readyTime;        }        @Override        public void run() {            readyTime = RANDOM.nextInt(1000);            System.out.println(name +"需要"+readyTime+"时间准备！");            try {                Thread.sleep(readyTime);            } catch (InterruptedException e) {                e.printStackTrace();            }            runnerReadyLatch.countDown();            try {                startMessageLatch.await();            } catch (InterruptedException e) {                e.printStackTrace();            }            if(ready){                System.out.println(name+"飞奔了出去！");            }else{                System.out.println(name+"未在规定时间准备就绪出局！");            }        }    }}